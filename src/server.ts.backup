#!/usr/bin/env node
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  Tool,
} from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";
import dotenv from "dotenv";
import { LettaClient } from "./letta-client.js";
import { WorkspaceManager } from "./workspace-manager.js";
import { ExecutionManager } from "./execution-manager.js";
import { TaskRegistry } from "./task-registry.js";
import {
  executeTask,
  ExecuteTaskSchema,
  type ExecuteTaskParams,
} from "./tools/execute-task.js";
import { runHTTP } from "./http-transport.js";
import { MatrixClientWrapper } from "./matrix-client.js";
import { MatrixRoomManager } from "./matrix-room-manager.js";
import { MatrixMessageRouter } from "./matrix-message-router.js";
import { ControlSignalHandler } from "./control-signal-handler.js";
import {
  sendTaskControl,
  SendTaskControlSchema,
} from "./tools/task-coordination-tools.js";
import {
  sendTaskMessage,
  SendTaskMessageSchema,
} from "./tools/task-message-tools.js";
import {
  getTaskStatus,
  GetTaskStatusSchema,
} from "./tools/task-status-tools.js";
import {
  getTaskHistory,
  GetTaskHistorySchema,
} from "./tools/task-archive-tools.js";

dotenv.config();

const DEBUG = process.env.DEBUG === "true";

function log(...args: unknown[]): void {
  if (DEBUG) {
    console.error("[letta-opencode-plugin]", ...args);
  }
}

const letta = new LettaClient({
  baseUrl: process.env.LETTA_API_URL || "https://letta.oculair.ca",
  token: process.env.LETTA_API_TOKEN || "",
  timeout: 30000,
  maxRetries: 3,
});

const workspace = new WorkspaceManager(letta);

const execution = new ExecutionManager({
  image: process.env.RUNNER_IMAGE || "ghcr.io/anthropics/claude-code:latest",
  cpuLimit: process.env.RUNNER_CPU_LIMIT || "2.0",
  memoryLimit: process.env.RUNNER_MEMORY_LIMIT || "2g",
  timeoutMs: parseInt(process.env.RUNNER_TIMEOUT_MS || "300000", 10),
  gracePeriodMs: 5000,
});

const registry = new TaskRegistry({
  maxConcurrentTasks: parseInt(process.env.MAX_CONCURRENT_TASKS || "3", 10),
  idempotencyWindowMs: 24 * 60 * 60 * 1000,
});

let matrixRoomManager: MatrixRoomManager | null = null;
let matrixMessageRouter: MatrixMessageRouter | null = null;
let controlSignalHandler: ControlSignalHandler | null = null;

if (process.env.MATRIX_ENABLED === "true") {
  const matrixClient = new MatrixClientWrapper({
    homeserverUrl: process.env.MATRIX_HOMESERVER_URL || "",
    accessToken: process.env.MATRIX_ACCESS_TOKEN || "",
    userId: process.env.MATRIX_USER_ID || "",
    storagePath: process.env.MATRIX_STORAGE_PATH,
  });
  
  matrixClient.start().then(() => {
    log("Matrix client started");
  }).catch((error) => {
    console.error("Failed to start Matrix client:", error);
  });
  
  matrixRoomManager = new MatrixRoomManager(matrixClient);
  
  controlSignalHandler = new ControlSignalHandler({
    execution,
    registry,
    workspace,
    matrix: matrixRoomManager,
  });
  
  matrixMessageRouter = new MatrixMessageRouter({
    matrix: matrixClient,
    rooms: matrixRoomManager,
    registry,
    workspace,
    controlHandler: controlSignalHandler,
  });
  matrixMessageRouter.start();
}

const server = new Server(
  {
    name: "letta-opencode-plugin",
    version: "0.1.0",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

const PingSchema = z.object({});

const HealthSchema = z.object({});

server.setRequestHandler(ListToolsRequestSchema, async () => {
  const tools: Tool[] = [
    {
      name: "ping",
      description: "Simple ping tool to verify the MCP server is responsive",
      inputSchema: {
        type: "object",
        properties: {},
      },
    },
    {
      name: "health",
      description: "Health check tool that returns server status and environment info",
      inputSchema: {
        type: "object",
        properties: {},
      },
    },
    {
      name: "opencode_execute_task",
      description:
        "Execute a development task using OpenCode. Returns task ID and status. " +
        "Use sync=true to wait for completion, or sync=false (default) to return immediately.",
      inputSchema: {
        type: "object",
        properties: {
          agent_id: {
            type: "string",
            description: "ID of the Letta agent requesting the task",
          },
          task_description: {
            type: "string",
            description: "Natural language description of the task to execute",
          },
          idempotency_key: {
            type: "string",
            description: "Optional key to prevent duplicate execution",
          },
          timeout_ms: {
            type: "number",
            description: "Optional task execution timeout in milliseconds",
          },
          sync: {
            type: "boolean",
            description:
              "If true, wait for task completion; if false, return immediately",
            default: false,
          },
          observers: {
            type: "array",
            items: { type: "string" },
            description: "Optional list of Matrix user IDs to invite as observers (e.g., @user:domain.com)",
          },
        },
        required: ["agent_id", "task_description"],
      },
    },
    {
      name: "list_task_channels",
      description:
        "List communication channels for active or completed OpenCode tasks. " +
        "These channels allow agents to coordinate and receive updates from running tasks.",
      inputSchema: {
        type: "object",
        properties: {
          agent_id: {
            type: "string",
            description: "Filter channels by agent ID that created the task",
          },
          include_completed: {
            type: "boolean",
            description: "Include completed tasks in the response",
            default: false,
          },
        },
      },
    },
    {
      name: "get_task_channel",
      description:
        "Get detailed information about a specific task's communication channel. " +
        "Use this to check participants, creation time, and associated workspace.",
      inputSchema: {
        type: "object",
        properties: {
          task_id: {
            type: "string",
            description: "Task ID to look up",
          },
          channel_id: {
            type: "string",
            description: "Direct channel ID (alternative to task_id)",
          },
        },
      },
    },
    {
      name: "send_task_update",
      description:
        "Send a status update or message to the task's communication channel. " +
        "Other agents monitoring this channel will receive your update.",
      inputSchema: {
        type: "object",
        properties: {
          task_id: {
            type: "string",
            description: "Task ID to send update to",
          },
          message: {
            type: "string",
            description: "Update message content",
          },
          event_type: {
            type: "string",
            description: "Category of update",
            enum: ["progress", "error", "status_change"],
            default: "progress",
          },
        },
        required: ["task_id", "message"],
      },
    },
    {
      name: "send_task_control",
      description:
        "Send a control signal to request task cancellation, pause, or resume. " +
        "The OpenCode agent executing the task will receive and process this signal.",
      inputSchema: {
        type: "object",
        properties: {
          task_id: {
            type: "string",
            description: "Task ID to control",
          },
          control: {
            type: "string",
            description: "Control action to request",
            enum: ["cancel", "pause", "resume"],
          },
          reason: {
            type: "string",
            description: "Optional explanation for the control signal",
          },
        },
        required: ["task_id", "control"],
      },
    },
    {
      name: "send_task_feedback",
      description:
        "Send feedback to a running task. Use this to provide clarifications, " +
        "corrections, guidance, or approval to the OpenCode agent executing the task.",
      inputSchema: {
        type: "object",
        properties: {
          task_id: {
            type: "string",
            description: "Task ID to send feedback to",
          },
          feedback: {
            type: "string",
            description: "Feedback message content",
          },
          feedback_type: {
            type: "string",
            description: "Type of feedback being provided",
            enum: ["clarification", "correction", "guidance", "approval"],
            default: "guidance",
          },
          metadata: {
            type: "object",
            description: "Optional additional metadata",
          },
        },
        required: ["task_id", "feedback"],
      },
    },
    {
      name: "send_runtime_update",
      description:
        "Send a runtime update to modify task context, requirements, or priority during execution. " +
        "The OpenCode agent will incorporate this new information into its work.",
      inputSchema: {
        type: "object",
        properties: {
          task_id: {
            type: "string",
            description: "Task ID to send update to",
          },
          update: {
            type: "string",
            description: "Update message content",
          },
          update_type: {
            type: "string",
            description: "Type of runtime update",
            enum: ["context_change", "requirement_change", "priority_change"],
            default: "context_change",
          },
          metadata: {
            type: "object",
            description: "Optional additional metadata",
          },
        },
        required: ["task_id", "update"],
      },
    },
    {
      name: "add_task_observer",
      description:
        "Add a human or agent observer to a running task's communication channel. " +
        "Observers can monitor progress and provide feedback. Human observers are read-only by default.",
      inputSchema: {
        type: "object",
        properties: {
          task_id: {
            type: "string",
            description: "Task ID to add observer to",
          },
          observer_id: {
            type: "string",
            description: "Matrix user ID (e.g., @user:domain.com) of the observer",
          },
          observer_type: {
            type: "string",
            description: "Type of observer",
            enum: ["human", "agent"],
            default: "human",
          },
          read_only: {
            type: "boolean",
            description: "Whether observer should have read-only access",
            default: true,
          },
        },
        required: ["task_id", "observer_id"],
      },
    },
    {
      name: "remove_task_observer",
      description:
        "Remove an observer from a task's communication channel.",
      inputSchema: {
        type: "object",
        properties: {
          task_id: {
            type: "string",
            description: "Task ID to remove observer from",
          },
          observer_id: {
            type: "string",
            description: "Matrix user ID of the observer to remove",
          },
        },
        required: ["task_id", "observer_id"],
      },
    },
    {
      name: "list_task_observers",
      description:
        "List all observers currently monitoring a task's communication channel.",
      inputSchema: {
        type: "object",
        properties: {
          task_id: {
            type: "string",
            description: "Task ID to list observers for",
          },
        },
        required: ["task_id"],
      },
    },
    {
      name: "get_task_history",
      description:
        "Retrieve the complete history of events and optionally artifacts for a task. " +
        "Useful for reviewing what happened during task execution.",
      inputSchema: {
        type: "object",
        properties: {
          task_id: {
            type: "string",
            description: "Task ID to retrieve history for",
          },
          include_artifacts: {
            type: "boolean",
            description: "Whether to include artifacts (files, outputs) in the response",
            default: false,
          },
        },
        required: ["task_id"],
      },
    },
    {
      name: "archive_task_conversation",
      description:
        "Archive a completed task's conversation and generate a summary. " +
        "Can only be used on completed, failed, or cancelled tasks.",
      inputSchema: {
        type: "object",
        properties: {
          task_id: {
            type: "string",
            description: "Task ID to archive",
          },
          summary: {
            type: "string",
            description: "Optional summary of the task conversation",
          },
        },
        required: ["task_id"],
      },
    },
  ];

  return { tools };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    if (name === "ping") {
      PingSchema.parse(args);
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({ status: "ok", timestamp: Date.now() }),
          },
        ],
      };
    }

    if (name === "health") {
      HealthSchema.parse(args);
      const health = {
        status: "healthy",
        timestamp: Date.now(),
        version: "0.1.0",
        environment: {
          letta_api_url: process.env.LETTA_API_URL || "not_configured",
          runner_image: process.env.RUNNER_IMAGE || "not_configured",
          mcp_port: process.env.MCP_PORT || "not_configured",
        },
        metrics: {
          active_tasks: registry.getRunningTasksCount(),
          can_accept_task: registry.canAcceptTask(),
        },
      };
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(health, null, 2),
          },
        ],
      };
    }

    if (name === "opencode_execute_task") {
      const params = ExecuteTaskSchema.parse(args) as ExecuteTaskParams;
      const result = await executeTask(params, {
        letta,
        workspace,
        execution,
        registry,
        matrix: matrixRoomManager,
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    }

    if (name === "list_task_channels") {
      const params = ListTaskChannelsSchema.parse(args);
      const result = await listTaskChannels(params, {
        registry,
        matrix: matrixRoomManager,
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    }

    if (name === "get_task_channel") {
      const params = GetTaskChannelSchema.parse(args);
      const result = await getTaskChannel(params, {
        registry,
        matrix: matrixRoomManager,
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    }

    if (name === "send_task_update") {
      const params = SendTaskUpdateSchema.parse(args);
      const result = await sendTaskUpdate(params, {
        registry,
        matrix: matrixRoomManager,
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    }

    if (name === "send_task_control") {
      const params = SendTaskControlSchema.parse(args);
      const result = await sendTaskControl(params, {
        registry,
        matrix: matrixRoomManager,
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    }

    if (name === "send_task_feedback") {
      const params = SendTaskFeedbackSchema.parse(args);
      const result = await sendTaskFeedback(params, {
        registry,
        workspace,
        matrix: matrixRoomManager,
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    }

    if (name === "send_runtime_update") {
      const params = SendRuntimeUpdateSchema.parse(args);
      const result = await sendRuntimeUpdate(params, {
        registry,
        workspace,
        matrix: matrixRoomManager,
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    }

    if (name === "add_task_observer") {
      const params = AddTaskObserverSchema.parse(args);
      const result = await addTaskObserver(params, {
        registry,
        matrix: matrixRoomManager,
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    }

    if (name === "remove_task_observer") {
      const params = RemoveTaskObserverSchema.parse(args);
      const result = await removeTaskObserver(params, {
        registry,
        matrix: matrixRoomManager,
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    }

    if (name === "list_task_observers") {
      const params = ListTaskObserversSchema.parse(args);
      const result = await listTaskObservers(params, {
        registry,
        matrix: matrixRoomManager,
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    }

    if (name === "get_task_history") {
      const params = GetTaskHistorySchema.parse(args);
      const result = await getTaskHistory(params, {
        registry,
        workspace,
        matrix: matrixRoomManager,
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    }

    if (name === "archive_task_conversation") {
      const params = ArchiveTaskConversationSchema.parse(args);
      const result = await archiveTaskConversation(params, {
        registry,
        workspace,
        matrix: matrixRoomManager,
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2),
          },
        ],
      };
    }

    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({ error: `Unknown tool: ${name}` }),
        },
      ],
      isError: true,
    };
  } catch (error) {
    log("Error handling tool call:", error);
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            error: error instanceof Error ? error.message : String(error),
          }),
        },
      ],
      isError: true,
    };
  }
});

async function main() {
  log("Starting Letta OpenCode Plugin MCP Server...");
  await runHTTP(server);
  log("Server connected and ready");
}

main().catch((error) => {
  console.error("Fatal error:", error);
  if (matrixMessageRouter) {
    matrixMessageRouter.stop();
  }
  if (matrixRoomManager) {
    void matrixRoomManager
      .getMatrixClient()
      .stop()
      .catch((stopError) => console.error("Failed to stop Matrix client:", stopError));
  }
  process.exit(1);
});
